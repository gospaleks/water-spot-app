<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/rs/gospaleks/waterspot/domain/use_case/LocationTrackingUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/rs/gospaleks/waterspot/domain/use_case/LocationTrackingUseCase.kt" />
              <option name="originalContent" value="package rs.gospaleks.waterspot.domain.use_case&#10;&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;import com.google.android.gms.location.Priority&#10;import com.google.android.gms.maps.model.LatLng&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;&#10;class LocationTrackingUseCase @Inject constructor(&#10;    private val fusedLocationClient: FusedLocationProviderClient&#10;) {&#10;    private val _currentLocation = MutableStateFlow&lt;LatLng?&gt;(null)&#10;    val currentLocation: StateFlow&lt;LatLng?&gt; = _currentLocation.asStateFlow()&#10;&#10;    private var isTracking = false&#10;&#10;    private val locationRequest = LocationRequest.Builder(3000L)&#10;        .setMinUpdateIntervalMillis(2000L)&#10;        .setPriority(Priority.PRIORITY_HIGH_ACCURACY)&#10;        .build()&#10;&#10;    private val locationCallback = object : LocationCallback() {&#10;        override fun onLocationResult(result: LocationResult) {&#10;            result.lastLocation?.let {&#10;                _currentLocation.value = LatLng(it.latitude, it.longitude)&#10;            }&#10;        }&#10;    }&#10;&#10;    @RequiresPermission(allOf = [android.Manifest.permission.ACCESS_FINE_LOCATION, android.Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    fun startTracking() {&#10;        if (!isTracking) {&#10;            fusedLocationClient.requestLocationUpdates(&#10;                locationRequest,&#10;                locationCallback,&#10;                Looper.getMainLooper()&#10;            )&#10;            isTracking = true&#10;        }&#10;    }&#10;&#10;    fun stopTracking() {&#10;        if (isTracking) {&#10;            fusedLocationClient.removeLocationUpdates(locationCallback)&#10;            isTracking = false&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package rs.gospaleks.waterspot.domain.use_case&#10;&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.location.LocationCallback&#10;import com.google.android.gms.location.LocationRequest&#10;import com.google.android.gms.location.LocationResult&#10;import com.google.android.gms.location.Priority&#10;import com.google.android.gms.maps.model.LatLng&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;&#10;class LocationTrackingUseCase @Inject constructor(&#10;    private val fusedLocationClient: FusedLocationProviderClient&#10;) {&#10;    private val _currentLocation = MutableStateFlow&lt;LatLng?&gt;(null)&#10;    val currentLocation: StateFlow&lt;LatLng?&gt; = _currentLocation.asStateFlow()&#10;&#10;    private var isTracking = false&#10;&#10;    private val locationRequest = LocationRequest.Builder(3000L)&#10;        .setMinUpdateIntervalMillis(2000L)&#10;        .setPriority(Priority.PRIORITY_HIGH_ACCURACY)&#10;        .build()&#10;&#10;    private val locationCallback = object : LocationCallback() {&#10;        override fun onLocationResult(result: LocationResult) {&#10;            result.lastLocation?.let {&#10;                _currentLocation.value = LatLng(it.latitude, it.longitude)&#10;            }&#10;        }&#10;    }&#10;&#10;    @RequiresPermission(allOf = [android.Manifest.permission.ACCESS_FINE_LOCATION, android.Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    fun startTracking() {&#10;        if (!isTracking) {&#10;            // Prvo pokušaj da dobiješ poslednju poznatu lokaciju&#10;            getLastKnownLocation()&#10;            &#10;            fusedLocationClient.requestLocationUpdates(&#10;                locationRequest,&#10;                locationCallback,&#10;                Looper.getMainLooper()&#10;            )&#10;            isTracking = true&#10;        }&#10;    }&#10;&#10;    @RequiresPermission(allOf = [android.Manifest.permission.ACCESS_FINE_LOCATION, android.Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    private fun getLastKnownLocation() {&#10;        fusedLocationClient.lastLocation.addOnSuccessListener { location -&gt;&#10;            location?.let {&#10;                Log.d(&quot;LocationTracking&quot;, &quot;Got last known location: ${it.latitude}, ${it.longitude}&quot;)&#10;                _currentLocation.value = LatLng(it.latitude, it.longitude)&#10;            }&#10;        }.addOnFailureListener { exception -&gt;&#10;            Log.e(&quot;LocationTracking&quot;, &quot;Failed to get last known location&quot;, exception)&#10;        }&#10;    }&#10;&#10;    fun stopTracking() {&#10;        if (isTracking) {&#10;            fusedLocationClient.removeLocationUpdates(locationCallback)&#10;            isTracking = false&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/rs/gospaleks/waterspot/presentation/screens/add_spot/AddSpotViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/rs/gospaleks/waterspot/presentation/screens/add_spot/AddSpotViewModel.kt" />
              <option name="originalContent" value="package rs.gospaleks.waterspot.presentation.screens.add_spot&#10;&#10;import android.Manifest&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.maps.model.LatLng&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlin.math.*&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import rs.gospaleks.waterspot.domain.auth.use_case.GetCurrentUserUseCase&#10;import rs.gospaleks.waterspot.domain.model.CleanlinessLevelEnum&#10;import rs.gospaleks.waterspot.domain.model.Spot&#10;import rs.gospaleks.waterspot.domain.model.SpotTypeEnum&#10;import rs.gospaleks.waterspot.domain.use_case.AddSpotUseCase&#10;import rs.gospaleks.waterspot.domain.use_case.LocationTrackingUseCase&#10;import rs.gospaleks.waterspot.presentation.components.UiEvent&#10;&#10;@HiltViewModel&#10;class AddSpotViewModel @Inject constructor(&#10;    private val locationTrackingUseCase: LocationTrackingUseCase,&#10;    private val getCurrentUserUseCase: GetCurrentUserUseCase,&#10;    private val addSpotUseCase: AddSpotUseCase&#10;) : ViewModel() {&#10;    var uiState by mutableStateOf(AddSpotUiState())&#10;        private set&#10;&#10;    var eventFlow = MutableSharedFlow&lt;UiEvent&gt;()&#10;        private set&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    fun startLocationUpdates() {&#10;        locationTrackingUseCase.startTracking()&#10;        observeLocation()&#10;    }&#10;&#10;    fun stopLocationUpdates() {&#10;        locationTrackingUseCase.stopTracking()&#10;    }&#10;&#10;    fun submit() {&#10;        if (!canSubmitSpot()) {&#10;            return&#10;        }&#10;&#10;        val currentUserIdResult = getCurrentUserUseCase()&#10;        val uid = currentUserIdResult.getOrNull()&#10;&#10;        if (uid == null) {&#10;            uiState = uiState.copy(errorMessage = &quot;User not authenticated&quot;)&#10;            return&#10;        }&#10;&#10;        val spot = Spot(&#10;            id = &quot;&quot;,&#10;            latitude = uiState.selectedLocation?.latitude ?: 0.0,&#10;            longitude = uiState.selectedLocation?.longitude ?: 0.0,&#10;            type = uiState.type ?: SpotTypeEnum.OTHER,&#10;            cleanliness = uiState.cleanliness ?: CleanlinessLevelEnum.CLEAN,&#10;            description = uiState.description,&#10;            userId = uid,&#10;            createdAt = System.currentTimeMillis(),&#10;            updatedAt = System.currentTimeMillis()&#10;        )&#10;&#10;        uiState = uiState.copy(isSubmitting = true, errorMessage = null)&#10;&#10;        viewModelScope.launch {&#10;           val result = addSpotUseCase(spot, uiState.photoUri!!)&#10;&#10;            uiState = if (result.isSuccess) {&#10;                eventFlow.emit(UiEvent.NavigateToHome)&#10;                uiState.copy(isSubmitting = false, errorMessage = null)&#10;            } else {&#10;                eventFlow.emit(UiEvent.Error)&#10;                Log.d(&quot;AddSpotViewModel&quot;, &quot;Failed to add spot: ${result.exceptionOrNull()?.message}&quot;)&#10;                uiState.copy(&#10;                    isSubmitting = false,&#10;                    errorMessage = &quot;Failed to add spot: ${result.exceptionOrNull()?.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setSelectedLocation(location: LatLng) {&#10;        uiState = uiState.copy(selectedLocation = location)&#10;    }&#10;&#10;    fun setPhotoUri(photoUri: Uri?) {&#10;        uiState = uiState.copy(photoUri = photoUri)&#10;    }&#10;&#10;    fun setType(type: SpotTypeEnum) {&#10;        uiState = uiState.copy(type = type)&#10;    }&#10;&#10;    fun setCleanliness(cleanliness: CleanlinessLevelEnum) {&#10;        uiState = uiState.copy(cleanliness = cleanliness)&#10;    }&#10;&#10;    fun setDescription(description: String?) {&#10;        uiState = uiState.copy(description = description)&#10;    }&#10;&#10;    fun shouldCenterCamera(): Boolean {&#10;        return !uiState.hasCenteredCamera&#10;    }&#10;&#10;    fun setCameraCentered() {&#10;        uiState = uiState.copy(hasCenteredCamera = true)&#10;    }&#10;&#10;    // Proverava da li moze submitovati spot&#10;    fun canSubmitSpot(): Boolean {&#10;        return uiState.selectedLocation != null &amp;&amp;&#10;               uiState.photoUri != null &amp;&amp;&#10;               uiState.type != null &amp;&amp;&#10;               uiState.cleanliness != null &amp;&amp;&#10;               isWithinRadius()&#10;//               &amp;&amp; uiState.description != null&#10;    }&#10;&#10;    // Proverava da li je lokacija unutar kruga&#10;    fun isWithinRadius(): Boolean {&#10;        val origin = uiState.startLocation ?: return false&#10;        val target = uiState.selectedLocation ?: return false&#10;        return distanceBetween(origin, target) &lt;= uiState.allowedRadiusMeters&#10;    }&#10;&#10;    // Haversine formula to calculate distance between two LatLng points&#10;    private fun distanceBetween(start: LatLng, end: LatLng): Double {&#10;        val earthRadius = 6371000.0 // meters&#10;        val dLat = Math.toRadians(end.latitude - start.latitude)&#10;        val dLon = Math.toRadians(end.longitude - start.longitude)&#10;        val lat1 = Math.toRadians(start.latitude)&#10;        val lat2 = Math.toRadians(end.latitude)&#10;&#10;        val a = sin(dLat / 2).pow(2) + sin(dLon / 2).pow(2) * cos(lat1) * cos(lat2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;&#10;    private fun observeLocation() = viewModelScope.launch {&#10;        locationTrackingUseCase.currentLocation.collect { location -&gt;&#10;            uiState = uiState.copy(startLocation = location)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package rs.gospaleks.waterspot.presentation.screens.add_spot&#10;&#10;import android.Manifest&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.annotation.RequiresPermission&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.lifecycle.ViewModel&#10;import com.google.android.gms.location.FusedLocationProviderClient&#10;import com.google.android.gms.maps.model.LatLng&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlin.math.*&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.tasks.await&#10;import rs.gospaleks.waterspot.domain.auth.use_case.GetCurrentUserUseCase&#10;import rs.gospaleks.waterspot.domain.model.CleanlinessLevelEnum&#10;import rs.gospaleks.waterspot.domain.model.Spot&#10;import rs.gospaleks.waterspot.domain.model.SpotTypeEnum&#10;import rs.gospaleks.waterspot.domain.use_case.AddSpotUseCase&#10;import rs.gospaleks.waterspot.domain.use_case.LocationTrackingUseCase&#10;import rs.gospaleks.waterspot.presentation.components.UiEvent&#10;&#10;@HiltViewModel&#10;class AddSpotViewModel @Inject constructor(&#10;    private val locationTrackingUseCase: LocationTrackingUseCase,&#10;    private val getCurrentUserUseCase: GetCurrentUserUseCase,&#10;    private val addSpotUseCase: AddSpotUseCase&#10;) : ViewModel() {&#10;    var uiState by mutableStateOf(AddSpotUiState())&#10;        private set&#10;&#10;    var eventFlow = MutableSharedFlow&lt;UiEvent&gt;()&#10;        private set&#10;&#10;    @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;    fun startLocationUpdates() {&#10;        // Prvo čitaj trenutnu vrednost ako postoji&#10;        val currentLocation = locationTrackingUseCase.currentLocation.value&#10;        if (currentLocation != null) {&#10;            uiState = uiState.copy(startLocation = currentLocation)&#10;        }&#10;        &#10;        locationTrackingUseCase.startTracking()&#10;        observeLocation()&#10;    }&#10;&#10;    fun stopLocationUpdates() {&#10;        locationTrackingUseCase.stopTracking()&#10;    }&#10;&#10;    fun submit() {&#10;        if (!canSubmitSpot()) {&#10;            return&#10;        }&#10;&#10;        val currentUserIdResult = getCurrentUserUseCase()&#10;        val uid = currentUserIdResult.getOrNull()&#10;&#10;        if (uid == null) {&#10;            uiState = uiState.copy(errorMessage = &quot;User not authenticated&quot;)&#10;            return&#10;        }&#10;&#10;        val spot = Spot(&#10;            id = &quot;&quot;,&#10;            latitude = uiState.selectedLocation?.latitude ?: 0.0,&#10;            longitude = uiState.selectedLocation?.longitude ?: 0.0,&#10;            type = uiState.type ?: SpotTypeEnum.OTHER,&#10;            cleanliness = uiState.cleanliness ?: CleanlinessLevelEnum.CLEAN,&#10;            description = uiState.description,&#10;            userId = uid,&#10;            createdAt = System.currentTimeMillis(),&#10;            updatedAt = System.currentTimeMillis()&#10;        )&#10;&#10;        uiState = uiState.copy(isSubmitting = true, errorMessage = null)&#10;&#10;        viewModelScope.launch {&#10;           val result = addSpotUseCase(spot, uiState.photoUri!!)&#10;&#10;            uiState = if (result.isSuccess) {&#10;                eventFlow.emit(UiEvent.NavigateToHome)&#10;                uiState.copy(isSubmitting = false, errorMessage = null)&#10;            } else {&#10;                eventFlow.emit(UiEvent.Error)&#10;                Log.d(&quot;AddSpotViewModel&quot;, &quot;Failed to add spot: ${result.exceptionOrNull()?.message}&quot;)&#10;                uiState.copy(&#10;                    isSubmitting = false,&#10;                    errorMessage = &quot;Failed to add spot: ${result.exceptionOrNull()?.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setSelectedLocation(location: LatLng) {&#10;        uiState = uiState.copy(selectedLocation = location)&#10;    }&#10;&#10;    fun setPhotoUri(photoUri: Uri?) {&#10;        uiState = uiState.copy(photoUri = photoUri)&#10;    }&#10;&#10;    fun setType(type: SpotTypeEnum) {&#10;        uiState = uiState.copy(type = type)&#10;    }&#10;&#10;    fun setCleanliness(cleanliness: CleanlinessLevelEnum) {&#10;        uiState = uiState.copy(cleanliness = cleanliness)&#10;    }&#10;&#10;    fun setDescription(description: String?) {&#10;        uiState = uiState.copy(description = description)&#10;    }&#10;&#10;    fun shouldCenterCamera(): Boolean {&#10;        return !uiState.hasCenteredCamera&#10;    }&#10;&#10;    fun setCameraCentered() {&#10;        uiState = uiState.copy(hasCenteredCamera = true)&#10;    }&#10;&#10;    // Proverava da li moze submitovati spot&#10;    fun canSubmitSpot(): Boolean {&#10;        return uiState.selectedLocation != null &amp;&amp;&#10;               uiState.photoUri != null &amp;&amp;&#10;               uiState.type != null &amp;&amp;&#10;               uiState.cleanliness != null &amp;&amp;&#10;               isWithinRadius()&#10;//               &amp;&amp; uiState.description != null&#10;    }&#10;&#10;    // Proverava da li je lokacija unutar kruga&#10;    fun isWithinRadius(): Boolean {&#10;        val origin = uiState.startLocation ?: return false&#10;        val target = uiState.selectedLocation ?: return false&#10;        return distanceBetween(origin, target) &lt;= uiState.allowedRadiusMeters&#10;    }&#10;&#10;    // Haversine formula to calculate distance between two LatLng points&#10;    private fun distanceBetween(start: LatLng, end: LatLng): Double {&#10;        val earthRadius = 6371000.0 // meters&#10;        val dLat = Math.toRadians(end.latitude - start.latitude)&#10;        val dLon = Math.toRadians(end.longitude - start.longitude)&#10;        val lat1 = Math.toRadians(start.latitude)&#10;        val lat2 = Math.toRadians(end.latitude)&#10;&#10;        val a = sin(dLat / 2).pow(2) + sin(dLon / 2).pow(2) * cos(lat1) * cos(lat2)&#10;        val c = 2 * atan2(sqrt(a), sqrt(1 - a))&#10;        return earthRadius * c&#10;    }&#10;&#10;    private fun observeLocation() = viewModelScope.launch {&#10;        locationTrackingUseCase.currentLocation.collect { location -&gt;&#10;            if (location != null) {&#10;                uiState = uiState.copy(startLocation = location)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/rs/gospaleks/waterspot/presentation/screens/map/components/SpotDetailsBottomSheet.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/rs/gospaleks/waterspot/presentation/screens/map/components/SpotDetailsBottomSheet.kt" />
              <option name="originalContent" value="package rs.gospaleks.waterspot.presentation.screens.map.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Navigation&#10;import androidx.compose.material.icons.outlined.Report&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import kotlinx.coroutines.delay&#10;import rs.gospaleks.waterspot.domain.model.SpotDetails&#10;import rs.gospaleks.waterspot.presentation.components.toDisplayName&#10;import rs.gospaleks.waterspot.presentation.components.icon&#10;import rs.gospaleks.waterspot.domain.model.User&#10;import rs.gospaleks.waterspot.presentation.components.CleanlinessChip&#10;import rs.gospaleks.waterspot.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SpotDetailsBottomSheet(&#10;    spotDetails: SpotDetails? = null,&#10;    isLoading: Boolean,&#10;    selectedSpotId: String? = null,&#10;    onDismiss: () -&gt; Unit,&#10;    onReviewClick: () -&gt; Unit,&#10;    onNavigateClick: () -&gt; Unit,&#10;    onLoadSpotDetails: (String) -&gt; Unit = {},&#10;    onUserProfileClick: () -&gt; Unit = {}&#10;) {&#10;    LaunchedEffect(selectedSpotId) {&#10;        selectedSpotId?.let { spotId -&gt;&#10;            // Mala pauza da se animacija otvaranja završi&#10;            delay(200)&#10;            onLoadSpotDetails(spotId)&#10;        }&#10;    }&#10;&#10;    ModalBottomSheet(&#10;        onDismissRequest = onDismiss,&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            if (isLoading || spotDetails == null) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxHeight(0.5f)&#10;                        .fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center,&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else {&#10;                SpotDetailsContent(&#10;                    spotDetails = spotDetails,&#10;                    onNavigateClick = onNavigateClick,&#10;                    onReviewClick = onReviewClick,&#10;                    onUserProfileClick = onUserProfileClick&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SpotDetailsContent(&#10;    spotDetails: SpotDetails,&#10;    onReviewClick: () -&gt; Unit = {},&#10;    onNavigateClick: () -&gt; Unit = {},&#10;    onUserProfileClick: () -&gt; Unit = {}&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Photo&#10;        spotDetails.spot.photoUrl?.let { photoUrl -&gt;&#10;            AsyncImage(&#10;                model = photoUrl,&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .aspectRatio(4f / 3f)&#10;                    .clip(RoundedCornerShape(16.dp)),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;        }&#10;&#10;        // Header with type and date&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Type with icon&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Icon(&#10;                    imageVector = spotDetails.spot.type.icon(),&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = spotDetails.spot.type.toDisplayName(),&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            }&#10;&#10;            // Cleanliness chip&#10;            CleanlinessChip(&#10;                cleanliness = spotDetails.spot.cleanliness,&#10;                modifier = Modifier.wrapContentWidth()&#10;            )&#10;        }&#10;&#10;        // Description&#10;        spotDetails.spot.description?.let { description -&gt;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = description,&#10;                modifier = Modifier.fillMaxWidth().padding(16.dp),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;&#10;        // Clickable user info&#10;        spotDetails.user?.let { user -&gt;&#10;            PostedByCard(user, onUserProfileClick)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(20.dp))&#10;&#10;        // Action buttons&#10;        ActionsButtons(&#10;            onNavigateClick = onNavigateClick,&#10;            onReviewClick = onReviewClick&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PostedByCard(&#10;    user: User,&#10;    onUserProfileClick: () -&gt; Unit,&#10;) {&#10;    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;    Card(&#10;        onClick = onUserProfileClick,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceContainer&#10;        ),&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            AsyncImage(&#10;                model = user.profilePictureUrl,&#10;                contentDescription = &quot;Profile picture&quot;,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clip(CircleShape),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Column {&#10;                Text(&#10;                    text = stringResource(R.string.spot_details_posted_by),&#10;                    style = MaterialTheme.typography.labelSmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Text(&#10;                    text = user.fullName,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ActionsButtons(&#10;    onNavigateClick: () -&gt; Unit,&#10;    onReviewClick: () -&gt; Unit,&#10;) {&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Button(&#10;            onClick = onNavigateClick,&#10;            modifier = Modifier.weight(1f),&#10;            contentPadding = PaddingValues(vertical = 12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Navigation,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(18.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(text = stringResource(R.string.spot_details_navigate_button))&#10;        }&#10;&#10;        OutlinedButton(&#10;            onClick = onReviewClick,&#10;            modifier = Modifier.weight(1f),&#10;            contentPadding = PaddingValues(vertical = 12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Outlined.Report,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(18.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(text = stringResource(R.string.spot_details_review_button))&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package rs.gospaleks.waterspot.presentation.screens.map.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowForward&#10;import androidx.compose.material.icons.filled.Navigation&#10;import androidx.compose.material.icons.outlined.Report&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import kotlinx.coroutines.delay&#10;import rs.gospaleks.waterspot.domain.model.SpotDetails&#10;import rs.gospaleks.waterspot.presentation.components.toDisplayName&#10;import rs.gospaleks.waterspot.presentation.components.icon&#10;import rs.gospaleks.waterspot.domain.model.User&#10;import rs.gospaleks.waterspot.presentation.components.CleanlinessChip&#10;import rs.gospaleks.waterspot.R&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun SpotDetailsBottomSheet(&#10;    spotDetails: SpotDetails? = null,&#10;    isLoading: Boolean,&#10;    selectedSpotId: String? = null,&#10;    onDismiss: () -&gt; Unit,&#10;    onReviewClick: () -&gt; Unit,&#10;    onNavigateClick: () -&gt; Unit,&#10;    onLoadSpotDetails: (String) -&gt; Unit = {},&#10;    onUserProfileClick: () -&gt; Unit = {}&#10;) {&#10;    LaunchedEffect(selectedSpotId) {&#10;        selectedSpotId?.let { spotId -&gt;&#10;            // Mala pauza da se animacija otvaranja završi&#10;            delay(200)&#10;            onLoadSpotDetails(spotId)&#10;        }&#10;    }&#10;&#10;    ModalBottomSheet(&#10;        onDismissRequest = onDismiss,&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            if (isLoading || spotDetails == null) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxHeight(0.5f)&#10;                        .fillMaxWidth(),&#10;                    contentAlignment = Alignment.Center,&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else {&#10;                SpotDetailsContent(&#10;                    spotDetails = spotDetails,&#10;                    onNavigateClick = onNavigateClick,&#10;                    onReviewClick = onReviewClick,&#10;                    onUserProfileClick = onUserProfileClick&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SpotDetailsContent(&#10;    spotDetails: SpotDetails,&#10;    onReviewClick: () -&gt; Unit = {},&#10;    onNavigateClick: () -&gt; Unit = {},&#10;    onUserProfileClick: () -&gt; Unit = {}&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Photo&#10;        spotDetails.spot.photoUrl?.let { photoUrl -&gt;&#10;            AsyncImage(&#10;                model = photoUrl,&#10;                contentDescription = null,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .aspectRatio(4f / 3f)&#10;                    .clip(RoundedCornerShape(16.dp)),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;        }&#10;&#10;        // Header with type and date&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Type with icon&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Icon(&#10;                    imageVector = spotDetails.spot.type.icon(),&#10;                    contentDescription = null,&#10;                    tint = MaterialTheme.colorScheme.primary,&#10;                    modifier = Modifier.size(24.dp)&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(&#10;                    text = spotDetails.spot.type.toDisplayName(),&#10;                    style = MaterialTheme.typography.headlineSmall,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            }&#10;&#10;            // Cleanliness chip&#10;            CleanlinessChip(&#10;                cleanliness = spotDetails.spot.cleanliness,&#10;                modifier = Modifier.wrapContentWidth()&#10;            )&#10;        }&#10;&#10;        // Description&#10;        spotDetails.spot.description?.let { description -&gt;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Text(&#10;                text = description,&#10;                modifier = Modifier.fillMaxWidth().padding(16.dp),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;        }&#10;&#10;        // Clickable user info&#10;        spotDetails.user?.let { user -&gt;&#10;            PostedByCard(user, onUserProfileClick)&#10;        }&#10;&#10;        Spacer(modifier = Modifier.height(20.dp))&#10;&#10;        // Action buttons&#10;        ActionsButtons(&#10;            onNavigateClick = onNavigateClick,&#10;            onReviewClick = onReviewClick&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PostedByCard(&#10;    user: User,&#10;    onUserProfileClick: () -&gt; Unit,&#10;) {&#10;    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;    Card(&#10;        onClick = onUserProfileClick,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceContainer&#10;        ),&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Row(&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            AsyncImage(&#10;                model = user.profilePictureUrl,&#10;                contentDescription = &quot;Profile picture&quot;,&#10;                modifier = Modifier&#10;                    .size(48.dp)&#10;                    .clip(CircleShape),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Column {&#10;                Text(&#10;                    text = stringResource(R.string.spot_details_posted_by),&#10;                    style = MaterialTheme.typography.labelSmall,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;                Text(&#10;                    text = user.fullName,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            }&#10;            Spacer(modifier = Modifier.weight(1f))&#10;            Icon(&#10;                imageVector = Icons.AutoMirrored.Filled.ArrowForward,&#10;                contentDescription = null,&#10;                tint = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                modifier = Modifier.size(20.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ActionsButtons(&#10;    onNavigateClick: () -&gt; Unit,&#10;    onReviewClick: () -&gt; Unit,&#10;) {&#10;    Row(&#10;        horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Button(&#10;            onClick = onNavigateClick,&#10;            modifier = Modifier.weight(1f),&#10;            contentPadding = PaddingValues(vertical = 12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Default.Navigation,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(18.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(text = stringResource(R.string.spot_details_navigate_button))&#10;        }&#10;&#10;        OutlinedButton(&#10;            onClick = onReviewClick,&#10;            modifier = Modifier.weight(1f),&#10;            contentPadding = PaddingValues(vertical = 12.dp)&#10;        ) {&#10;            Icon(&#10;                imageVector = Icons.Outlined.Report,&#10;                contentDescription = null,&#10;                modifier = Modifier.size(18.dp)&#10;            )&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;            Text(text = stringResource(R.string.spot_details_review_button))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>